#!/usr/bin/env python

from __future__ import print_function

import argparse, json, string
import os, sys, traceback

args = None
lccdir = '/usr/local/lib/gigatron-lcc'
current_module = None
current_proc = None
interface_dict = {}
map_dict = {}
safe_dict = None
module_list = []


## locate errors in .s/.o/.a files

def where(tb=None):
    stb = traceback.extract_tb(tb, limit=8) if tb else \
          traceback.extract_stack(limit=8)
    for s in stb:
        if (s[2] == 'code'):
            return "{0}:{1}".format(s[0],s[1])
    return None

### module class

class Module:
    def __init__(self, code=None, name=None, cpu=None):
        global args, current_module
        self.code = code
        self.name = name
        self.cpu = cpu if cpu != None else args.cpu
        self.exports = {}
        self.externs = {}

### vocabulary for exec-ing .s/.o/.a files

class Vocabulary:
    ''' This is not a class but just a way to construct a dictionary
        with the words that can be used by .s/.o/.a files. '''
    def pc():
        return current_proc.pc()
    def v(x):
        return x if isinstance(x,int) else current_module.v(x)
    def lo(x):
        return v(x) & 0xff
    def hi(x):
        return (v(x) >> 8) & 0xff
    def error(s):
        w = where()
        current_proc.error(f"glink: {w}: error: {s}")
    def warning(s):
        w = where()
        current_proc.warning(f"glink: {w}: warning: {s}")
    def fatal(s):
        w = where()
        w = "" if w == None else w + ": "
        print(f"glink: {w}fatal error: {s}", file=sys.stderr)
        sys.exit(1)
    def module(code=None,name=None,cpu=None):
        global module_list
        if current_module or current_proc:
            warning("module() should not be called from the code fragment")
        else:
            module_list.append(Module(code,name,cpu))

### copy vocabulary namespace into actual globals

def copy_dict_into(d,g):
    for n in d:
        if not n.startswith('__') and not n.endswith('__'):
            g[n] = d[n]

copy_dict_into(vars(Vocabulary), globals())

### safely read .s/.o/.a files
              
def new_globals():
    global safe_dict
    if safe_dict == None:
        safe_dict = { '__builtins__' : None }
        copy_dict_into(interface_dict, safe_dict)
        copy_dict_into(vars(Vocabulary), safe_dict)
    return safe_dict.copy()

def read_file(f):
    global code, current_module, current_proc
    with open(f,'r') as fd: 
        c = compile(fd.read(),f,'exec')
    n = len(module_list)
    current_module = None
    current_proc = None
    exec(c, new_globals())
    if len(module_list) <= n:
        fatal(f"no module found")

def read_lib(l, safe=True):
    for d in (args.L or []) + [lccdir]:
        f = os.path.join(d, f"lib{l}.a")
        if os.access(f, os.R_OK):
            return read_file(f)
    fatal(f"library -l{l} not found!")
        
### main function

def main(argv):
    global lccdir, args
    global interface_syms
    
    try:
        ## Find LCCDIR
        lccdir = os.getenv("LCCDIR", default=lccdir)
        
        ## Parsing arguments
        parser = argparse.ArgumentParser(
            conflict_handler='resolve',allow_abbrev=False,
            usage='glink [options] {<files.o>} -l<lib> -o <outfile.gt1>',
            description='Collects gigatron .{s,o,a} files into a .gt1 file.',
            epilog='''This program accepts the modules generated by gigatron-lcc/rcc
            (suffix .s or .o). These files are text files with a python
            syntax. They contain a single function that defines all the
            VCPU instructions, labels and data for this module.  Glink
            also accepts concatenation of such files forming a library
            (suffix .a).  The cpu, rom, and map options provide values
            than handcrafted code inside a module can test to select
            different implementations. The cpu option enables instructions
            that were added in successive implementations of the Gigatron
            VCPU.  The rom option informs the libraries about the
            availability of natively implemented SYS functions. The map
            option tells at which addresses the program, the data, and the
            stack should be located. It also tells which zero page
            location are used as registers by the compiled code and which
            runtime libraries should be loaded by default. The final
            output file includes the module that exports the entry point
            symbol, then the modules that exports all the symbols that it
            imports, then recursively all the modules that are needed to
            resolve imported symbols.''')
        parser.add_argument('-o', type=str, default='a.gt1', metavar='file.gt1',
                            help='select the output filename (default: a.gt1)')
        parser.add_argument('-cpu', type=str, action='store',
                            help='select the target cpu version')
        parser.add_argument('-rom', type=str, action='store',
                            help='select the target rom version')
        parser.add_argument('-map', type=str, action='store',
                            help='select a linker map')
        parser.add_argument('-d', action='store_true',
                            help='enable debug output')
        parser.add_argument('-e', type=str, action='store', default='_start',
                            help='select the entry point symbol (default _start)')
        parser.add_argument('files', type=str, nargs='+',
                            help='input files')
        parser.add_argument('-l', type=str, action='append',
                            help='library files. -lxxx searches for libxxx.a')
        parser.add_argument('-L', type=str, action='append',
                            help='additional library directories')
        args = parser.parse_args(argv)
        if args.map == None:
            args.map = '64k'
        if args.cpu == None:
            args.cpu = 5
        if args.rom == None:
            args.rom = 'v5a'

        ### Read interface.json
        with open(lccdir + '/interface.json') as file:
            for (name, value) in json.load(file).items():
                interface_dict[name] = value if isinstance(value, int) else int(value, base=0)

        ### Read map

        ### Load .s/.o/.a files
        for f in args.files or []:
            read_file(f)
        for f in args.l or []:
            read_lib(f)

        return 0
    except FileNotFoundError as err:
        fatal(str(err))
    
if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
