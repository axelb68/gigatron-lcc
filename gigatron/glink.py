#!/usr/bin/env python
from __future__ import print_function
import argparse, json, os, sys



args = None
lccdir = '/usr/local/lib/gigatron-lcc'
interface_syms = {}


def main(argv):
    global lccdir, args
    global interface_syms
    
    try:
        ## Find LCCDIR
        lccdir = os.getenv("LCCDIR", default=lccdir)
        
        ## Parsing arguments
        parser = argparse.ArgumentParser(
            conflict_handler='resolve',allow_abbrev=False,
            usage='glink [options] {<files.o>} -l<lib> -o <outfile.gt1>',
            description='Collects gigatron .{s,o,a} files into a .gt1 file.',
            epilog='''This program accepts the modules generated by gigatron-lcc/rcc
            (suffix .s or .o). These files are text files with a python
            syntax. They contain a single function that defines all the
            VCPU instructions, labels and data for this module.  Glink
            also accepts concatenation of such files forming a library
            (suffix .a).  The cpu, rom, and map options provide values
            than handcrafted code inside a module can test to select
            different implementations. The cpu option enables instructions
            that were added in successive implementations of the Gigatron
            VCPU.  The rom option informs the libraries about the
            availability of natively implemented SYS functions. The map
            option tells at which addresses the program, the data, and the
            stack should be located. It also tells which zero page
            location are used as registers by the compiled code and which
            runtime libraries should be loaded by default. The final
            output file includes the module that exports the entry point
            symbol, then the modules that exports all the symbols that it
            imports, then recursively all the modules that are needed to
            resolve imported symbols.''')
        parser.add_argument('-o', type=str, default='a.gt1', metavar='file.gt1',
                            help='select the output filename (default: a.gt1)')
        parser.add_argument('-cpu', type=str, action='store',
                            help='select the target cpu version')
        parser.add_argument('-rom', type=str, action='store',
                            help='select the target rom version')
        parser.add_argument('-map', type=str, action='store',
                            help='select a linker map')
        parser.add_argument('-d', action='store_true',
                            help='enable debug output')
        parser.add_argument('-e', type=str, action='store', default='_start',
                            help='select the entry point symbol (default _start)')
        parser.add_argument('files', type=str, nargs='+',
                            help='input files')
        parser.add_argument('-l', type=str, action='append',
                            help='library files. -lxxx searches for libxxx.a')
        args = parser.parse_args(argv)
        if args.map == None:
            args.map = '64k'
        if args.cpu == None:
            args.cpu = 5
        if args.rom == None:
            args.rom = 'v5a'

        ### Read interface.json
        with open(lccdir + '/interface.json') as file:  
            for (name, value) in json.load(file).items():
                interface_syms[name] = value if isinstance(value, int) else int(value, base=0)

        ### Read map.json

        ## Execute
        assemble_and_link(args)
        return 0
    except Exception as err:
        print("glink: ", err, file=sys.stderr)
        return 1
    
if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
    
# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
