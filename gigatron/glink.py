#!/usr/bin/env python

from __future__ import print_function

import argparse, json, string
import os, sys, traceback

args = None
lccdir = '/usr/local/lib/gigatron-lcc'
current_module = None
current_proc = None
module_list = []
global_dict = {}

## locate errors in .s/.o/.a files

def where(tb=None):
    stb = traceback.extract_tb(tb, limit=8) if tb else \
          traceback.extract_stack(limit=8)
    for s in stb:
        if (s[2] == 'code'):
            return "{0}:{1}".format(s[0],s[1])
    return None

## vocabulary for execing .s/.o/.a files

def v(x):
    return x if isinstance(x,int) else current_module.v(x)
def lo(x):
    return v(x) & 0xff
def hi(x):
    return (v(x) >> 8) & 0xff
def error(s):
    w = where()
    current_proc.error(f"{w}: glink error: {s}")
def warning(s):
    w = where()
    current_proc.warning(f"{w}: glink warning: {s}")
def fatal(s):
    w = where()
    s = f"{w}: {s}" if isinstance(w,str) else s
    print(s, file=sys.stderr)
    sys.exit(1)


## safelty read .s/.o/.a files

class Module:
    def __init__(self, code=None, name=None, cpu=None):
        global args, current_module
        self.code = code
        self.name = name
        self.cpu = cpu if cpu != None else args.cpu
        self.exports = {}
        self.externs = {}
        module_list.append(self)

def safe_globals(safe=True):
    gg = globals()
    sg = { '__builtins__' : None }
    if safe:
        for n in ['v','lo','hi','error','warning','fatal','args',
                  'Module'] :
            sg[n] = gg[n]
        return sg
    return gg
              
def read_file(f):
    global code, module_list
    with open(f,'r') as fd: 
        c = compile(fd.read(),f,'exec')
    n = len(module_list)
    exec(c, safe_globals())
    if len(module_list) <= n:
        fatal(f"{f}: glink fatal error: no module found")

def read_lib(l, safe=True):
    for d in (args.L or []) + [lccdir]:
        f = os.path.join(d, f"lib{l}.a")
        if os.access(f, os.R_OK):
            return read_file(f)
    fatal(f"glink fatal error: library -l{l} not found!")
        
### main function

def main(argv):
    global lccdir, args
    global interface_syms
    
    try:
        ## Find LCCDIR
        lccdir = os.getenv("LCCDIR", default=lccdir)
        
        ## Parsing arguments
        parser = argparse.ArgumentParser(
            conflict_handler='resolve',allow_abbrev=False,
            usage='glink [options] {<files.o>} -l<lib> -o <outfile.gt1>',
            description='Collects gigatron .{s,o,a} files into a .gt1 file.',
            epilog='''This program accepts the modules generated by gigatron-lcc/rcc
            (suffix .s or .o). These files are text files with a python
            syntax. They contain a single function that defines all the
            VCPU instructions, labels and data for this module.  Glink
            also accepts concatenation of such files forming a library
            (suffix .a).  The cpu, rom, and map options provide values
            than handcrafted code inside a module can test to select
            different implementations. The cpu option enables instructions
            that were added in successive implementations of the Gigatron
            VCPU.  The rom option informs the libraries about the
            availability of natively implemented SYS functions. The map
            option tells at which addresses the program, the data, and the
            stack should be located. It also tells which zero page
            location are used as registers by the compiled code and which
            runtime libraries should be loaded by default. The final
            output file includes the module that exports the entry point
            symbol, then the modules that exports all the symbols that it
            imports, then recursively all the modules that are needed to
            resolve imported symbols.''')
        parser.add_argument('-o', type=str, default='a.gt1', metavar='file.gt1',
                            help='select the output filename (default: a.gt1)')
        parser.add_argument('-cpu', type=str, action='store',
                            help='select the target cpu version')
        parser.add_argument('-rom', type=str, action='store',
                            help='select the target rom version')
        parser.add_argument('-map', type=str, action='store',
                            help='select a linker map')
        parser.add_argument('-d', action='store_true',
                            help='enable debug output')
        parser.add_argument('-e', type=str, action='store', default='_start',
                            help='select the entry point symbol (default _start)')
        parser.add_argument('files', type=str, nargs='+',
                            help='input files')
        parser.add_argument('-l', type=str, action='append',
                            help='library files. -lxxx searches for libxxx.a')
        parser.add_argument('-L', type=str, action='append',
                            help='additional library directories')
        args = parser.parse_args(argv)
        if args.map == None:
            args.map = '64k'
        if args.cpu == None:
            args.cpu = 5
        if args.rom == None:
            args.rom = 'v5a'

        ### Read interface.json
        with open(lccdir + '/interface.json') as file:  
            for (name, value) in json.load(file).items():
                global_dict[name] = value if isinstance(value, int) else int(value, base=0)

        ### Read map

        ### Load .s/.o/.a files
        print(args)
        for f in args.files or []:
            read_file(f)
        for f in args.l or []:
            read_lib(f)

        return 0
    except FileNotFoundError as err:
        fatal(f"glink fatal error: {err}")
    
if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
